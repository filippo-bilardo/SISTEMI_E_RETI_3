# 5. Sicurezza nelle VPN

La sicurezza è l'aspetto fondamentale di ogni implementazione VPN. Comprendere gli algoritmi crittografici, i metodi di autenticazione e le vulnerabilità potenziali è essenziale per configurare una VPN robusta e affidabile.

## 5.1 Algoritmi di crittografia

Gli algoritmi di crittografia sono il cuore della sicurezza VPN, trasformando i dati in chiaro in formato illeggibile.

### AES (Advanced Encryption Standard)

**AES** è l'algoritmo simmetrico più utilizzato e raccomandato per le VPN moderne.

#### Caratteristiche tecniche
```
Tipo: Cifrario a blocchi simmetrico
Dimensione blocco: 128 bit
Dimensioni chiave: 128, 192, 256 bit
Rounds: 10 (128-bit), 12 (192-bit), 14 (256-bit)
Standard: NIST FIPS 197
```

#### Modalità operative AES

**CBC (Cipher Block Chaining)**
```
Plaintext Block[n] ⊕ Ciphertext Block[n-1] → AES Encrypt → Ciphertext Block[n]
```
- Richiede IV (Initialization Vector)
- Vulnerabile a padding oracle attacks
- Non più raccomandato per TLS

**GCM (Galois/Counter Mode)** ✅ Raccomandato
```
Counter → AES Encrypt → XOR con Plaintext → Ciphertext + Authentication Tag
```
- AEAD (Authenticated Encryption with Associated Data)
- Autenticazione integrata
- Parallelizzabile (veloce)
- Standard per IPsec e TLS 1.3

**CTR (Counter Mode)**
```
Counter + Nonce → AES Encrypt → XOR con Plaintext → Ciphertext
```
- Trasforma cifrario a blocchi in stream cipher
- Parallelizzabile
- No padding required

#### Performance AES

```
Hardware con AES-NI (Intel/AMD):
AES-128-GCM: ~10-20 GB/s per core
AES-256-GCM: ~7-15 GB/s per core

Hardware senza AES-NI:
AES-128: ~200-500 MB/s
AES-256: ~150-400 MB/s
```

**AES-NI** (AES New Instructions) è un set di istruzioni CPU che accelera drasticamente AES:
```bash
# Verificare supporto AES-NI su Linux
grep aes /proc/cpuinfo

# Verificare supporto su Windows
wmic cpu get caption,name | findstr /i "AES"
```

#### Configurazioni raccomandate

**Ottime:**
- `AES-256-GCM` - Massima sicurezza, buone performance con AES-NI
- `AES-128-GCM` - Sicurezza eccellente, performance migliori

**Accettabili:**
- `AES-256-CBC` - Solo se GCM non disponibile
- `AES-128-CBC` - Legacy systems

**Da evitare:**
- `AES-*-ECB` - Non sicuro (pattern visibili)

### ChaCha20

**ChaCha20** è un algoritmo stream cipher moderno, alternativa a AES.

#### Caratteristiche
```
Tipo: Stream cipher
Dimensione chiave: 256 bit
Designer: Daniel J. Bernstein
Performance: Ottima su dispositivi senza AES-NI
```

#### ChaCha20-Poly1305 (AEAD)
```
ChaCha20 (encryption) + Poly1305 (authentication)
```

**Vantaggi:**
- Veloce su CPU senza AES-NI (ARM, mobile)
- Resistente a timing attacks
- Implementazione più semplice di AES
- Adottato da Google, Cloudflare

**Quando usare ChaCha20:**
- Dispositivi mobile (smartphone, tablet)
- Dispositivi IoT embedded
- CPU senza AES-NI
- OpenVPN, WireGuard

**Benchmark comparativo:**
```
CPU senza AES-NI:
ChaCha20:  ~1.5 GB/s
AES-256:   ~300 MB/s

CPU con AES-NI:
AES-256-GCM: ~15 GB/s
ChaCha20:    ~1.5 GB/s
```

### 3DES (Triple DES)

**DEPRECATO** - Non utilizzare per nuove implementazioni.

#### Perché evitare 3DES
❌ Lento (3x più lento di AES)  
❌ Dimensione blocco piccola (64 bit) - vulnerabile a Sweet32  
❌ Chiave effettiva 112 bit (teorici 168 bit)  
❌ NIST ha deprecato 3DES nel 2023  

**Rimpiazzare con:**
- AES-128 minimo
- AES-256 raccomandato

### Blowfish

Algoritmo legacy, superato da algoritmi più moderni.

**Limitazioni:**
- Dimensione blocco 64 bit (vulnerabile a Sweet32)
- Chiavi fino a 448 bit (inutilmente lunghe)
- Performance inferiori a AES su hardware moderno

**Uso residuo:** Alcune installazioni legacy di OpenVPN.

**Migrazione consigliata:** AES-256-GCM o ChaCha20-Poly1305

### Comparazione algoritmi

| Algoritmo | Chiave | Blocco | Performance | Sicurezza | Raccomandazione |
|-----------|--------|--------|-------------|-----------|-----------------|
| **AES-256-GCM** | 256 bit | 128 bit | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ✅ Eccellente |
| **AES-128-GCM** | 128 bit | 128 bit | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ✅ Ottima |
| **ChaCha20-Poly1305** | 256 bit | Stream | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ✅ Mobile/IoT |
| 3DES | 168 bit | 64 bit | ⭐ | ⭐⭐ | ❌ Deprecato |
| Blowfish | 448 bit | 64 bit | ⭐⭐ | ⭐⭐⭐ | ⚠️ Legacy |
| RC4 | 128 bit | Stream | ⭐⭐ | ❌ | ❌ Insicuro |

## 5.2 Protocolli di autenticazione

L'autenticazione verifica l'identità degli endpoint VPN prima di stabilire il tunnel.

### Pre-Shared Keys (PSK)

Chiavi simmetriche condivise manualmente tra gli endpoint.

#### Formato PSK
```bash
# IPsec PSK
@client1.example.com : PSK "a8f5c923bd8e1234567890abcdef1234"

# OpenVPN static key
-----BEGIN OpenVPN Static key V1-----
6acef03f62675b4b1bdc4130d9c4f6c5
3c5f2b0e1d9a8e7f4c3b2a1d0e9f8c7b
...
-----END OpenVPN Static key V1-----
```

#### Vantaggi PSK
✅ Configurazione semplice e veloce  
✅ Nessuna PKI da gestire  
✅ Ideale per piccole reti (2-10 dispositivi)  
✅ Nessun certificato da rinnovare

#### Svantaggi PSK
❌ Non scala (gestione manuale per ogni connessione)  
❌ Compromissione di una chiave compromette tutte le connessioni  
❌ Difficile revoca (richiede riconfigurazione)  
❌ Nessuna identità individuale (audit complesso)  
❌ Trasmissione sicura della chiave problematica

#### Best Practices PSK

**Generazione chiavi forti:**
```bash
# Linux - generare PSK random (hex, 64 caratteri)
openssl rand -hex 32

# Base64 (più leggibile)
openssl rand -base64 32

# Passphrase (128+ caratteri consigliati)
pwgen 128 1
```

**Requisiti minimi PSK:**
- Minimo 128 bit di entropia (16 byte)
- Preferibile 256 bit (32 byte)
- Caratteri random (no parole dizionario)
- Cambio periodico (es. ogni 6-12 mesi)

**Storage sicuro:**
```bash
# Permessi restrittivi su file PSK
chmod 600 /etc/ipsec.secrets
chown root:root /etc/ipsec.secrets

# Crittografia del filesystem
# Utilizzare LUKS o dm-crypt per /etc
```

### Certificati Digitali (PKI)

Sistema basato su infrastruttura a chiave pubblica per autenticazione scalabile.

#### Componenti PKI

**Certificate Authority (CA)**
```
Root CA (offline, massima sicurezza)
  └── Intermediate CA (operativa)
       ├── Server Certificates
       └── Client Certificates
```

**Struttura certificato X.509:**
```
Certificate:
    Version: 3 (0x2)
    Serial Number: 4096 (0x1000)
    Signature Algorithm: sha256WithRSAEncryption
    Issuer: CN=VPN-CA, O=Company, C=IT
    Validity
        Not Before: Jan  1 00:00:00 2024 GMT
        Not After : Dec 31 23:59:59 2025 GMT
    Subject: CN=vpn-client-alice, O=Company, C=IT
    Subject Public Key Info:
        Public Key Algorithm: rsaEncryption
            RSA Public-Key: (2048 bit)
    X509v3 Extensions:
        X509v3 Key Usage: critical
            Digital Signature, Key Encipherment
        X509v3 Extended Key Usage:
            TLS Web Client Authentication
```

#### Creazione CA con OpenSSL

**1. Configurazione CA**
```bash
# openssl.cnf
[ ca ]
default_ca = CA_default

[ CA_default ]
dir              = /etc/pki/CA
certs            = $dir/certs
crl_dir          = $dir/crl
new_certs_dir    = $dir/newcerts
database         = $dir/index.txt
serial           = $dir/serial
certificate      = $dir/cacert.pem
private_key      = $dir/private/cakey.pem
default_md       = sha256
default_days     = 365
```

**2. Generare Root CA**
```bash
# Generare chiave privata CA (protetta da passphrase)
openssl genrsa -aes256 -out ca-key.pem 4096

# Generare certificato CA (auto-firmato)
openssl req -new -x509 -days 3650 -key ca-key.pem -sha256 -out ca-cert.pem \
  -subj "/C=IT/ST=Lombardia/L=Milano/O=Company/CN=VPN-CA"
```

**3. Generare certificato server**
```bash
# Generare chiave privata server
openssl genrsa -out server-key.pem 2048

# Generare CSR (Certificate Signing Request)
openssl req -new -key server-key.pem -out server.csr \
  -subj "/C=IT/O=Company/CN=vpn.company.com"

# Firmare con CA
openssl x509 -req -days 365 -in server.csr -CA ca-cert.pem -CAkey ca-key.pem \
  -CAcreateserial -out server-cert.pem -sha256 \
  -extfile <(echo "subjectAltName=DNS:vpn.company.com,DNS:vpn2.company.com")
```

**4. Generare certificato client**
```bash
# Chiave client
openssl genrsa -out client-alice-key.pem 2048

# CSR client
openssl req -new -key client-alice-key.pem -out client-alice.csr \
  -subj "/C=IT/O=Company/CN=alice"

# Firmare
openssl x509 -req -days 365 -in client-alice.csr -CA ca-cert.pem -CAkey ca-key.pem \
  -CAcreateserial -out client-alice-cert.pem -sha256 \
  -extfile <(echo "extendedKeyUsage=clientAuth")
```

#### Revoca certificati

**Certificate Revocation List (CRL)**
```bash
# Revocare certificato
openssl ca -revoke client-alice-cert.pem -keyfile ca-key.pem -cert ca-cert.pem

# Generare CRL
openssl ca -gencrl -keyfile ca-key.pem -cert ca-cert.pem -out crl.pem

# Configurare VPN per controllare CRL
# OpenVPN server.conf:
crl-verify /etc/openvpn/crl.pem
```

**OCSP (Online Certificate Status Protocol)**
```bash
# Server OCSP
openssl ocsp -port 8080 -text -CA ca-cert.pem \
  -index index.txt -rkey ca-key.pem -rsigner ca-cert.pem

# Client check
openssl ocsp -CAfile ca-cert.pem -issuer ca-cert.pem -cert client-cert.pem \
  -url http://ocsp.company.com:8080
```

#### Vantaggi PKI
✅ Scalabilità per migliaia di utenti  
✅ Revoca granulare (CRL, OCSP)  
✅ Identità individuale per audit  
✅ Scadenza automatica certificati  
✅ Mutual authentication (server e client)  
✅ Standard industry (X.509)

#### Svantaggi PKI
❌ Complessità setup iniziale  
❌ Gestione CA richiede competenze  
❌ Rinnovo periodico certificati  
❌ Overhead amministrativo  
❌ PKI compromise = disastro totale

### RADIUS (Remote Authentication Dial-In User Service)

Protocollo AAA (Authentication, Authorization, Accounting) centralizzato.

#### Architettura RADIUS
```
┌──────────┐         ┌──────────┐         ┌─────────────┐
│  Client  │──(1)──→ │   VPN    │──(2)──→ │   RADIUS    │
│          │         │ Gateway  │         │   Server    │
│          │         │          │         │             │
│          │ ←──(5)──│          │←──(4)───│             │
└──────────┘         └──────────┘         └──────┬──────┘
                                                  │ (3)
                                            ┌─────┴──────┐
                                            │  Backend   │
                                            │ (AD, LDAP, │
                                            │  Database) │
                                            └────────────┘

(1) Client → Gateway: Username/Password
(2) Gateway → RADIUS: Access-Request
(3) RADIUS → Backend: Query credenziali
(4) RADIUS → Gateway: Access-Accept/Reject
(5) Gateway → Client: Connessione granted/denied
```

#### Configurazione FreeRADIUS

**Installazione:**
```bash
# Debian/Ubuntu
apt install freeradius freeradius-utils

# CentOS/RHEL
yum install freeradius freeradius-utils
```

**clients.conf** (definire VPN gateway)
```bash
client vpn-gateway {
    ipaddr = 192.168.1.100
    secret = RadiusSharedSecret123!
    shortname = vpn-gw
    nas_type = other
}
```

**users** (definire utenti)
```bash
alice   Cleartext-Password := "password123"
        Reply-Message = "Welcome Alice",
        Framed-IP-Address = 10.8.0.10

bob     Cleartext-Password := "securepass456"
        Reply-Message = "Welcome Bob",
        Framed-IP-Address = 10.8.0.11
```

**Integrazione con LDAP/Active Directory:**
```bash
# modules/ldap
ldap {
    server = "ldap.company.com"
    identity = "cn=admin,dc=company,dc=com"
    password = adminpass
    base_dn = "ou=users,dc=company,dc=com"
    
    user {
        filter = "(uid=%{%{Stripped-User-Name}:-%{User-Name}})"
        base_dn = "${..base_dn}"
    }
}
```

**OpenVPN + RADIUS:**
```bash
# OpenVPN server.conf
plugin /usr/lib/openvpn/radiusplugin.so /etc/openvpn/radiusplugin.cnf

# radiusplugin.cnf
NAS-Identifier=OpenVPN
Service-Type=5
Framed-Protocol=1
NAS-Port-Type=5
NAS-IP-Address=192.168.1.100
server
{
    acctport=1813
    authport=1812
    name=192.168.1.200
    retry=1
    wait=1
    sharedsecret=RadiusSharedSecret123!
}
```

#### RADIUS Accounting
```
Start Session:
  Accounting-Request (Start)
    Acct-Session-Id
    User-Name
    NAS-IP-Address
    Acct-Status-Type = Start

During Session (periodic):
  Accounting-Request (Interim-Update)
    Acct-Input-Octets
    Acct-Output-Octets
    Session-Time

End Session:
  Accounting-Request (Stop)
    Acct-Session-Time
    Acct-Input-Octets
    Acct-Output-Octets
    Acct-Terminate-Cause
```

### TACACS+

Protocollo AAA alternativo, più comune in ambienti Cisco.

#### TACACS+ vs RADIUS

| Feature | TACACS+ | RADIUS |
|---------|---------|--------|
| **Protocollo** | TCP 49 | UDP 1812/1813 |
| **Crittografia** | Tutto il payload | Solo password |
| **AAA Separation** | ✅ Separato | ❌ Combinato |
| **Granularità** | Command-by-command | Per-session |
| **Vendor** | Cisco (proprietary) | Open standard |
| **Accounting** | Dettagliato | Base |

**Quando usare TACACS+:**
- Ambiente prevalentemente Cisco
- Necessità di command authorization
- Accounting dettagliato richiesto

**Quando usare RADIUS:**
- Multi-vendor environment
- Standard aperti preferiti
- VPN authentication

## 5.3 Gestione delle chiavi

La gestione sicura delle chiavi crittografiche è cruciale per la sicurezza VPN.

### Lifecycle delle chiavi

```
┌──────────────┐
│  Generation  │ ← Creare chiavi con entropia sufficiente
└──────┬───────┘
       │
┌──────▼───────┐
│ Distribution │ ← Trasmissione sicura agli endpoint
└──────┬───────┘
       │
┌──────▼───────┐
│   Storage    │ ← Protezione chiavi at-rest
└──────┬───────┘
       │
┌──────▼───────┐
│     Usage    │ ← Utilizzo per crittografia
└──────┬───────┘
       │
┌──────▼───────┐
│   Rotation   │ ← Cambio periodico chiavi
└──────┬───────┘
       │
┌──────▼───────┐
│ Destruction  │ ← Eliminazione sicura
└──────────────┘
```

### Key Derivation

Derivazione di chiavi da master secret.

**HKDF (HMAC-based Key Derivation Function)**
```
Master Key → HKDF-Extract → Pseudo-Random Key (PRK)
                                    ↓
                            HKDF-Expand
                                    ↓
              ┌─────────────────────┴─────────────────────┐
              │                     │                     │
         Encryption Key      Authentication Key      IV/Nonce
```

**Esempio in IKEv2:**
```
SKEYSEED = prf(Ni | Nr, g^ir)
{SK_d | SK_ai | SK_ar | SK_ei | SK_er | SK_pi | SK_pr} = prf+(SKEYSEED, ...)

SK_d  = Derivation key (per ulteriori chiavi)
SK_ai = Initiator authentication key
SK_ar = Responder authentication key
SK_ei = Initiator encryption key
SK_er = Responder encryption key
SK_pi = Initiator payload authentication
SK_pr = Responder payload authentication
```

### Key Storage

**Hardware Security Module (HSM)**
```
┌─────────────────────────────────┐
│     Hardware Security Module    │
│                                 │
│  ┌───────────────────────────┐  │
│  │  Tamper-Resistant         │  │
│  │  Storage                  │  │
│  │                           │  │
│  │  ┌─────────────────────┐  │  │
│  │  │  Private Keys       │  │  │
│  │  │  (never exported)   │  │  │
│  │  └─────────────────────┘  │  │
│  └───────────────────────────┘  │
│                                 │
│  API: Crypto operations only    │
│  (sign, decrypt, unwrap)        │
└─────────────────────────────────┘
```

**Software key storage:**
```bash
# Encrypted filesystem
# LUKS su Linux
cryptsetup luksFormat /dev/sdb1
cryptsetup open /dev/sdb1 secure_keys
mkfs.ext4 /dev/mapper/secure_keys
mount /dev/mapper/secure_keys /etc/vpn_keys

# Permessi restrittivi
chmod 700 /etc/vpn_keys
chmod 600 /etc/vpn_keys/*.key
chown root:root /etc/vpn_keys/*.key

# SELinux/AppArmor per isolation
```

### Key Rotation

Cambio periodico delle chiavi per limitare esposizione.

**Rekey automatico IPsec:**
```bash
# strongSwan
conn myVPN
    keylife=8h          # IPsec SA lifetime
    rekeymargin=3m      # Rekeying 3 min prima scadenza
    keyingtries=%forever # Riprova all'infinito
    ikelifetime=24h     # IKE SA lifetime
```

**OpenVPN rekeying:**
```bash
# Automatic rekeying
reneg-sec 3600  # Renegozia ogni ora

# Per traffico
reneg-bytes 64000000  # Dopo 64MB
reneg-pkts 1000000    # Dopo 1M pacchetti
```

**Frequenze raccomandate:**
- **IKE SA**: 24 ore
- **IPsec SA**: 1-8 ore o dopo throughput limite
- **Certificati**: 1 anno (max 2 anni)
- **CA certificate**: 5-10 anni
- **PSK**: 6-12 mesi

## 5.4 Perfect Forward Secrecy (PFS)

**Perfect Forward Secrecy** garantisce che la compromissione di una chiave non comprometta sessioni passate.

### Come funziona PFS

**Senza PFS:**
```
Master Key compromessa → Tutte le sessioni registrate decriptabili
```

**Con PFS:**
```
Session Key₁ compromessa → Solo Session₁ decriptabile
Session Key₂, Key₃, ... → Rimangono sicure
```

### Implementazione

**Diffie-Hellman Ephemeral (DHE/ECDHE)**
```
Sessione 1:
  Alice genera: a (random, ephemeral)
  Bob genera:   b (random, ephemeral)
  Shared Secret: g^(ab) mod p
  → Chiave session 1

Sessione 2:
  Alice genera: a' (nuovo random)
  Bob genera:   b' (nuovo random)
  Shared Secret: g^(a'b') mod p
  → Chiave session 2 (indipendente da session 1)
```

**Cipher suites con PFS:**
✅ `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384`  
✅ `TLS_DHE_RSA_WITH_AES_256_GCM_SHA384`  
✅ `TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305`

**Senza PFS (da evitare):**
❌ `TLS_RSA_WITH_AES_256_CBC_SHA256`  
❌ `TLS_RSA_WITH_AES_128_GCM_SHA256`

### Configurazione PFS

**OpenVPN:**
```bash
# PFS abilitato di default in OpenVPN
# Usa ephemeral keys per ogni sessione
tls-cipher TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384
```

**IPsec/strongSwan:**
```bash
conn myVPN
    # PFS Groups (DH)
    ike=aes256-sha256-modp2048!      # Group 14
    esp=aes256-sha256-modp2048!      # PFS group 14
    
    # Oppure ECC (più veloce)
    ike=aes256-sha256-ecp256!        # Group 19
    esp=aes256-sha256-ecp256!
```

**Benefici PFS:**
✅ Session independence  
✅ Protezione da future compromissioni  
✅ Compliance normativo (GDPR, PCI-DSS)

**Trade-off:**
⚠️ Overhead computazionale maggiore  
⚠️ Handshake leggermente più lento

## 5.5 Vulnerabilità e minacce

### Attacchi comuni alle VPN

#### 1. Man-in-the-Middle (MITM)

**Scenario:**
```
Client → [Attacker intercetta] → VPN Server
```

**Mitigazioni:**
- ✅ Mutual authentication con certificati
- ✅ Verificare fingerprint certificato server
- ✅ Certificate pinning
- ✅ Usare tls-auth/tls-crypt (OpenVPN)

#### 2. Replay Attacks

**Scenario:**
Attaccante cattura pacchetti VPN e li ritrasmette.

**Mitigazioni:**
- ✅ Sequence numbers (IPsec)
- ✅ Timestamp (IKE)
- ✅ Anti-replay window
- ✅ Nonce in handshake

**Configurazione:**
```bash
# IPsec - default abilitato
# OpenVPN - default abilitato
replay-window 64  # Finestra anti-replay
```

#### 3. Downgrade Attacks

Forzare uso di algoritmi deboli.

**Mitigazioni:**
```bash
# OpenVPN - specificare cipher esplicite
cipher AES-256-GCM
tls-version-min 1.2
tls-cipher TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384

# IPsec - usare "!" per forzare
ike=aes256-sha256-modp2048!
esp=aes256-sha256!
```

#### 4. DNS Leaks

Richieste DNS bypassano VPN.

**Test:**
```bash
# Durante connessione VPN
dig @8.8.8.8 myip.opendns.com TXT
nslookup myip.opendns.com resolver1.opendns.com
```

**Mitigazioni:**
```bash
# OpenVPN - force DNS
push "dhcp-option DNS 10.8.0.1"
push "block-outside-dns"  # Windows

# Linux - update-resolv-conf script
script-security 2
up /etc/openvpn/update-resolv-conf
down /etc/openvpn/update-resolv-conf
```

#### 5. IP Leaks (IPv6)

Traffico IPv6 bypassa tunnel IPv4.

**Mitigazioni:**
```bash
# Disabilitare IPv6 se VPN non lo supporta
echo "net.ipv6.conf.all.disable_ipv6 = 1" >> /etc/sysctl.conf
sysctl -p

# Oppure configurare IPv6 in VPN
# OpenVPN
server-ipv6 fd00::/64
push "route-ipv6 ::/0"
```

#### 6. Port Forwarding Attacks

**Mitigazioni:**
```bash
# Disabilitare port forwarding sui client
# OpenVPN
push "block-ipv6"
route-nopull  # Impedire route push malicious

# Firewall client-side
iptables -A FORWARD -i tun0 -j DROP
iptables -A FORWARD -o tun0 -j DROP
```

### Vulnerabilità specifiche protocolli

#### PPTP Vulnerabilities
❌ **MS-CHAPv2**: vulnerabile a brute-force  
❌ **Encryption**: può essere crackato  
❌ **Authentication**: multiple vulnerabilità  
**Raccomandazione: Non usare PPTP**

#### L2TP/IPsec Issues
⚠️ **NAT traversal**: problematico  
⚠️ **Configurazione**: complessa  
⚠️ **Performance**: overhead doppio (L2TP + IPsec)

#### OpenVPN Vulnerabilities
**CVE-2017-7478**: Buffer overflow (fixato)  
**CVE-2017-7479**: Double-free (fixato)  
**Mitigazione: Mantenere aggiornato**

```bash
# Check versione
openvpn --version
# Aggiornare regolarmente
apt update && apt upgrade openvpn
```

### Vulnerabilità implementative

#### Weak Randomness
```bash
# Verificare random number generator
cat /proc/sys/kernel/random/entropy_avail

# Se < 1000, installare haveged
apt install haveged
systemctl enable haveged
```

#### Side-Channel Attacks
- Timing attacks
- Cache attacks
- Power analysis

**Mitigazioni:**
- Usare implementazioni constant-time
- Hardware con AES-NI (resistente a timing)
- Blinding techniques per RSA

## 5.6 Best Practices di sicurezza

### Configurazione

✅ **Usare protocolli moderni**: IKEv2, OpenVPN, WireGuard  
✅ **Cifratura forte**: AES-256-GCM o ChaCha20-Poly1305  
✅ **Hashing forte**: SHA-256 minimum, SHA-384/512 preferibile  
✅ **Perfect Forward Secrecy**: Sempre abilitare  
✅ **Certificate-based auth**: Preferire a PSK per deployment grandi

### Hardening

```bash
# OpenVPN hardening
tls-version-min 1.2
tls-cipher TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384:TLS-ECDHE-RSA-WITH-CHACHA20-POLY1305-SHA256
cipher AES-256-GCM
auth SHA256
tls-crypt ta.key  # Offuscation + auth
remote-cert-tls server  # Verify server cert
user nobody
group nogroup
```

### Monitoring

```bash
# Log analysis
tail -f /var/log/openvpn/openvpn.log | grep -E 'Failed|Error|Disconnect'

# Alert su eventi sospetti
fail2ban per tentativi autenticazione falliti

# SIEM integration
rsyslog → Splunk/ELK Stack
```

### Patching e Updates

```bash
# Schedule aggiornamenti regolari
apt update && apt upgrade
yum update

# Subscribe security mailing lists
- OpenVPN security advisories
- strongSwan security announcements
- CVE feeds
```

### Least Privilege

```bash
# Limita accesso VPN per group
iptables -A INPUT -i tun0 -m group --group vpn_users -j ACCEPT

# Split-tunneling policies
push "route 192.168.1.0 255.255.255.0"  # Solo LAN aziendale
# Resto del traffico non passa per VPN
```

### Backup e Recovery

```bash
# Backup regolare configurazioni
tar czf vpn-backup-$(date +%Y%m%d).tar.gz /etc/openvpn /etc/ipsec.*

# Backup CA e certificati (offline, encrypted)
gpg -c ca-key.pem
mv ca-key.pem.gpg /secure/offline/storage/
```

---

**Capitolo precedente**: [04. Protocolli VPN](04.Protocolli_VPN.md)  
**Prossimo capitolo**: [06. Architetture VPN](06.Architetture_VPN.md)
